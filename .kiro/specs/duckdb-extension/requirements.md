# 요구사항 문서

## 개요

이 스펙은 libdplyr 프로젝트를 DuckDB 확장 프로그램으로 변환하는 기능을 정의합니다. 현재 libdplyr는 독립 실행형 CLI 애플리케이션이지만, 이를 DuckDB 내에서 직접 사용할 수 있는 확장 프로그램으로 만들어 사용자가 DuckDB 쿼리 내에서 dplyr 파이프라인을 직접 사용할 수 있도록 합니다.

**ID 참조 규칙**: Rn-ACm 형식의 요구사항 ID를 design.md/tasks.md에서 그대로 사용

## 요구사항

### 요구사항 R1: DuckDB 쿼리 내 dplyr 파이프라인 사용

**사용자 스토리:** 데이터 분석가로서 DuckDB 쿼리 내에서 dplyr 파이프라인을 직접 사용하여 DuckDB 환경을 벗어나지 않고도 친숙한 R 스타일 데이터 조작 문법을 활용하고 싶습니다.

#### 인수 기준

1. **R1-AC1**: WHEN dplyr 파이프라인을 포함한 쿼리가 실행될 때 THEN 시스템은 변환된 SQL을 DuckDB 표준 파서로 전달하고 동일한 결과를 반환해야 한다
2. **R1-AC2**: WHEN 최소 연산 집합(select, filter, mutate, arrange, summarise, group_by)이 사용될 때 THEN 시스템은 등가 SQL을 생성해야 한다
3. **R1-AC3**: WHEN 변환이 실패할 때 THEN 시스템은 에러 코드(E-SYNTAX, E-UNSUPPORTED 등), 원인 토큰, 위치, 간단한 대안을 포함한 에러 메시지를 제공해야 한다

### 요구사항 R2: 표준 SQL과의 혼용 지원

**사용자 스토리:** DuckDB 사용자로서 dplyr 확장이 기존 DuckDB 기능과 원활하게 통합되어 표준 SQL 연산과 함께 사용할 수 있기를 원합니다.

#### 인수 기준

1. **R2-AC1**: WHEN 확장이 로드될 때 THEN 하나 이상의 진입점(함수, 매크로, 테이블 함수 등 - 구체적 명명은 설계에서 결정)이 등록되어야 한다
2. **R2-AC2**: WHEN 동일 쿼리 내에서 표준 SQL과 변환된 SQL이 사용될 때 THEN CTE 및 서브쿼리를 포함하여 함께 실행될 수 있어야 한다
3. **R2-AC3**: WHEN 미지원 연산이 발견될 때 THEN 시스템은 명시적 에러 코드와 가이드를 제공해야 한다

#### 비범위
- 본 버전은 DDL 문 내 dplyr 파이프라인 혼용을 지원하지 않는다(향후 버전에서 재검토)

### 요구사항 R3: C 호환 API 제공

**사용자 스토리:** 개발자로서 libdplyr가 C 호환 API를 노출하여 DuckDB의 C++ 확장 시스템과 통합할 수 있기를 원합니다.

#### 인수 기준

1. **R3-AC1**: WHEN libdplyr가 빌드될 때 THEN C ABI로 내보낸 심볼을 포함한 라이브러리(정적/동적 중 최소 1종 필수, 우선순위: 정적)를 지원 플랫폼(부록 A 참조)별로 생성해야 한다
2. **R3-AC2**: WHEN C++ 코드가 libdplyr API를 호출할 때 THEN 호출자는 변환 결과를 구조적 형태(성공/에러/메시지)로 수신해야 한다
3. **R3-AC3**: WHEN API가 메모리를 할당할 때 THEN 전용 해제 함수로 정리할 수 있어야 하며 소유권 규약이 명시되어야 한다

### 요구사항 R4: 자동 빌드 및 배포

**사용자 스토리:** 시스템 관리자로서 dplyr 확장이 자동으로 빌드되고 배포되어 사용자가 다양한 플랫폼에서 쉽게 설치하고 사용할 수 있기를 원합니다.

#### 인수 기준

1. **R4-AC1**: WHEN CI가 실행될 때 THEN 지원 플랫폼(부록 A 참조)별로 Rust 및 C++ 컴포넌트 빌드가 성공해야 한다
2. **R4-AC2**: WHEN 확장이 빌드될 때 THEN DuckDB에서 `LOAD 'dplyr_extension'`이 성공하고, tests/smoke.sql에 정의된 스모크 쿼리 1건 이상이 성공해야 한다
3. **R4-AC3**: WHEN 배포가 실행될 때 THEN GitHub Releases에 바이너리 게시는 필수이며, Community repo 등록은 정책 충족 시 선택적으로 수행해야 한다

### 요구사항 R5: 전용 키워드 기반 진입점

**사용자 스토리:** 데이터 엔지니어로서 dplyr 확장이 명확한 전용 키워드를 통해 dplyr 코드와 일반 SQL을 구분할 수 있기를 원합니다.

#### 인수 기준

1. **R5-AC1**: WHEN `DPLYR 'pipeline'` 구문이 사용될 때 THEN 시스템은 이를 dplyr 전용 구문으로 식별해야 한다
2. **R5-AC2**: WHEN 전용 키워드 외부에서 dplyr 유사 구문이 발견될 때 THEN 시스템은 표준 SQL로 처리하고 오탐을 방지해야 한다
3. **R5-AC3**: WHEN dplyr 구문 파싱이 실패할 때 THEN 시스템은 명확한 에러를 반환하고 표준 SQL로 폴백하지 않아야 한다

#### 정책
- 진입점은 `DPLYR 'pipeline'` 키워드 기반으로 명확히 구분
- 자유형 구문 감지(regex, %>% 패턴 등)는 오탐 위험으로 인해 사용하지 않음
- 모호함 없는 명시적 구문으로 사용자 혼란 최소화

### 요구사항 R6: 성능 특성 유지

**사용자 스토리:** 성능을 중시하는 사용자로서 dplyr 확장이 허용 가능한 성능 특성을 유지하여 쿼리 실행이 효율적으로 유지되기를 원합니다.

#### 인수 기준

1. **R6-AC1**: WHEN 단순 파이프라인이 변환될 때 THEN 변환 지연 P95는 2ms 미만이어야 하고, 복잡 파이프라인 P95는 15ms 미만이어야 한다(로컬, N=1000)
2. **R6-AC2**: WHEN 확장이 로드될 때 THEN 추가 지연 P95는 50ms 미만이어야 한다
3. **R6-AC3**: WHEN 동일 쿼리를 100회 반복 실행한 후 THEN RSS 증가율은 10% 미만이어야 하며 메모리 누수가 없어야 한다

#### 측정 환경
- 3회 워밍업 후 측정, CPU 고정, 동일 데이터셋 사용
- RSS 측정은 ps/rss 또는 valgrind massif 등 표준 도구 사용
- 정의와 시나리오는 별도 벤치마크 문서(추가 예정) 참조
- 파이프라인 복잡도 정의는 부록 B 용어 정의 참조

### 요구사항 R7: 포괄적 테스트 커버리지

**사용자 스토리:** 품질 보증 엔지니어로서 dplyr 확장에 대한 포괄적인 테스트를 통해 다양한 사용 사례에서 안정성이 유지되기를 원합니다.

#### 인수 기준

1. **R7-AC1**: WHEN 확장이 테스트될 때 THEN DuckDB 통합 테스트(LOAD/실행/결과 비교)가 포함되어야 한다
2. **R7-AC2**: WHEN SQL 방언 호환성이 테스트될 때 THEN DuckDB 전용 SQL 생성 검증 및 호환성 회귀 테스트가 포함되어야 한다
3. **R7-AC3**: WHEN 오류 시나리오가 테스트될 때 THEN DuckDB 크래시 없이 에러를 반환해야 하며 FFI 경계에서 panic이 억제되어야 한다
4. **R7-AC4**: WHEN 코드 커버리지가 측정될 때 THEN 핵심 경로(구문 감지→변환→SQL 생성→FFI 반환, 생성된 SQL의 DuckDB 파서 재주입 포함)의 라인 및 분기 커버리지가 70% 이상이어야 한다

### 요구사항 R8: 모범 사례 및 문서화

**사용자 스토리:** 유지보수자로서 확장이 DuckDB의 확장 개발 모범 사례를 따라 DuckDB 생태계와 잘 통합되기를 원합니다.

#### 인수 기준

1. **R8-AC1**: WHEN 확장이 구조화될 때 THEN DuckDB 지원 버전 범위, semver 정책, 폐기/비호환 변경 공지 정책(CHANGELOG.md/GitHub Release Notes, 최소 1 마이너 버전 사전 공지)이 명시되어야 한다
2. **R8-AC2**: WHEN 확장이 문서화될 때 THEN 사용자 가이드, C-API 사용법, 에러 카탈로그, 예제 쿼리, 트러블슈팅 가이드, 버전별 예제 호환성 표가 제공되어야 한다
3. **R8-AC3**: WHEN 릴리스 노트가 작성될 때 THEN 호환 범위 및 주요 변경사항이 포함되어야 한다

### 요구사항 R9: 보안 및 안정성

**사용자 스토리:** 보안을 중시하는 사용자로서 dplyr 확장이 오류를 안전하게 처리하여 DuckDB의 안정성을 손상시키지 않기를 원합니다.

#### 인수 기준

1. **R9-AC1**: WHEN FFI 함수가 호출될 때 THEN 모든 함수는 `panic` 전파를 방지해야 한다
2. **R9-AC2**: WHEN 입력이 처리될 때 THEN 입력 길이 및 인코딩 검증과 DoS 방지 제한이 적용되어야 한다
3. **R9-AC3**: WHEN FFI API가 멀티스레드에서 호출될 때 THEN 스레드 안전하게 호출 가능하거나, 비안전 시 문서로 명시되어야 한다

### 요구사항 R10: 가시성 및 진단

**사용자 스토리:** 개발자로서 dplyr 확장에서 진단 기능을 통해 문제를 효과적으로 해결할 수 있기를 원합니다.

#### 인수 기준

1. **R10-AC1**: WHEN 디버깅이 필요할 때 THEN 환경변수 또는 세션 옵션으로 디버그 로그를 토글할 수 있어야 한다
2. **R10-AC2**: WHEN 변환이 실행될 때 THEN 변환 시간, 경고 수 등 메타데이터를 하나 이상의 채널(PRAGMA/세션 함수/로그)을 통해 선택적으로 노출할 수 있어야 한다

---

## 부록

### 부록 A: 지원 플랫폼

| 플랫폼 | 아키텍처 | 지원 상태 |
|--------|----------|-----------|
| macOS | arm64, x86_64 | 지원 |
| Linux | x86_64 | 지원 |
| Windows | x86_64 | 지원 |

### 부록 B: 용어 정의

- **진입점**: DuckDB에서 dplyr 기능에 접근하는 방법 (함수, 매크로, 테이블 함수 등)
- **파이프라인**: `%>%` 연산자로 연결된 dplyr 연산들의 체인
- **단순 파이프라인**: 3개 이하 연산, group_by 미포함
- **복잡 파이프라인**: 4개 이상 연산 또는 group_by 포함
- **폴백**: 기본 처리 방식으로 되돌아가는 것 (여기서는 표준 SQL 파싱)
- **최상위 파이프라인 컨텍스트**: 서브쿼리 내부 최상위, 괄호 레벨 기준으로 판단하는 dplyr 파이프라인 감지 범위
- **FFI 경계**: Rust와 C++ 간의 Foreign Function Interface 호출 지점
- **스모크 쿼리**: 기본 기능 동작을 확인하는 간단한 테스트 쿼리
- **P95**: 95번째 백분위수 (측정값의 95%가 이 값 이하)
- **RSS**: Resident Set Size (프로세스가 실제 사용하는 물리 메모리 크기)

### 부록 C: 에러 메시지 정책

- **기본 언어**: 에러 메시지는 영어를 기본으로 하며, 운영 환경에서의 일관성을 위해 권장됨
- **에러 코드 체계**: 
  - `E-SYNTAX`: 구문 오류
  - `E-UNSUPPORTED`: 지원되지 않는 기능
  - `E-INTERNAL`: 내부 처리 오류
  - `E-FFI`: FFI 경계 오류

### 부록 D: 문서 정책

- **기본 언어**: 문서는 한국어 기본, 에러 메시지는 운영 일관성상 영어
- **ID 참조 규칙**: tasks.md, design.md에서 Rx-ACy 형식으로 요구사항 참조